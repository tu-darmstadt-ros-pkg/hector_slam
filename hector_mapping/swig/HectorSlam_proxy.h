/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */
#ifndef _HectorSlam_proxy_H_
#define _HectorSlam_proxy_H_

/* -----------------------------------------------------------------------------
 * cproxy.swg
 *
 * Definitions of C specific preprocessor symbols for proxies.
 * ----------------------------------------------------------------------------- */

#ifndef SWIGIMPORT
# ifndef __GNUC__
#   define __DLL_IMPORT __declspec(dllimport)
# else
#   define __DLL_IMPORT __attribute__((dllimport)) extern
# endif
# if !defined (__WIN32__)
#   define SWIGIMPORT extern
# else
#   define SWIGIMPORT __DLL_IMPORT
# endif
#endif

#include <stdio.h>

typedef struct {
  void *obj;
  const char **typenames;
} SwigObj;


// special value indicating any type of exception like 'catch(...)'
#define SWIG_AnyException "SWIG_AnyException"

#include <setjmp.h>

SWIGIMPORT jmp_buf SWIG_rt_env;

SWIGIMPORT struct SWIG_exc_struct {
  int code;
  char *msg;
  SwigObj *klass;
} SWIG_exc;

SWIGIMPORT void SWIG_rt_try();
SWIGIMPORT int SWIG_rt_catch(const char *type);
SWIGIMPORT void SWIG_rt_throw(SwigObj *klass, const char * msg);
SWIGIMPORT int SWIG_rt_unhandled();
SWIGIMPORT void SWIG_rt_endtry();
SWIGIMPORT int SWIG_exit(int code);

#define SWIG_try \
  SWIG_rt_try(); \
  if ((SWIG_exc.code = setjmp(SWIG_rt_env)) == 0) 
#define SWIG_catch(type) else if (SWIG_rt_catch(#type))
#define SWIG_throw(klass) SWIG_rt_throw((SwigObj *) klass, 0);
#define SWIG_throw_msg(klass, msg) SWIG_rt_throw((SwigObj *) klass, msg);
#define SWIG_endtry else SWIG_rt_unhandled(); SWIG_rt_endtry();



#include <stdarg.h>

#define SWIG_MAKE_DELETE(Name,Obj) void Name(Obj *op1, ...) {\
  Obj *obj;\
  va_list vl;\
  va_start(vl, op1);\
  do {\
    obj = va_arg(vl, Obj *);\
    delete_##Obj(obj);\
  } while (obj);\
  va_end(vl);\
}

/*aaaaaa*/SwigObj * Eigen_Vector2f(float carg1, float carg2);
float Eigen_Vector2f_x(SwigObj * carg1);
float Eigen_Vector2f_y(SwigObj * carg1);
float Eigen_Vector3f_x(SwigObj * carg1);
float Eigen_Vector3f_y(SwigObj * carg1);
float Eigen_Vector3f_z(SwigObj * carg1);
const char * SimdInstructionSetsInUse();
#define STAGE10_FULL_EIGEN2_API 10
#define STAGE20_RESOLVE_API_CONFLICTS 20
#define STAGE30_FULL_EIGEN3_API 30
#define STAGE40_FULL_EIGEN3_STRICTNESS 40
#define STAGE99_NO_EIGEN2_SUPPORT 99
#define EIGEN2_SUPPORT_STAGE 99

typedef SwigObj LogOddsCell;

void LogOddsCell_set(SwigObj * carg1, float carg2);
float LogOddsCell_getValue(SwigObj * carg1);
#include <stdbool.h>
bool LogOddsCell_isOccupied(SwigObj * carg1);
bool LogOddsCell_isFree(SwigObj * carg1);
void LogOddsCell_resetGridCell(SwigObj * carg1);
void LogOddsCell_logOddsVal_set(SwigObj * carg1, float carg2);
float LogOddsCell_logOddsVal_get(SwigObj * carg1);
void LogOddsCell_updateIndex_set(SwigObj * carg1, int carg2);
int LogOddsCell_updateIndex_get(SwigObj * carg1);
LogOddsCell * new_LogOddsCell();
void delete_LogOddsCell(LogOddsCell * carg1);

typedef SwigObj GridMapLogOddsFunctions;

GridMapLogOddsFunctions * new_GridMapLogOddsFunctions();
void GridMapLogOddsFunctions_updateSetOccupied(SwigObj * carg1, SwigObj * carg2);
void GridMapLogOddsFunctions_updateSetFree(SwigObj * carg1, SwigObj * carg2);
void GridMapLogOddsFunctions_updateUnsetFree(SwigObj * carg1, SwigObj * carg2);
float GridMapLogOddsFunctions_getGridProbability(SwigObj * carg1, SwigObj * carg2);
void GridMapLogOddsFunctions_setUpdateFreeFactor(SwigObj * carg1, float carg2);
void GridMapLogOddsFunctions_setUpdateOccupiedFactor(SwigObj * carg1, float carg2);
void delete_GridMapLogOddsFunctions(GridMapLogOddsFunctions * carg1);

typedef SwigObj HectorSlamProcessor;

HectorSlamProcessor * new_HectorSlamProcessor_f_i_i_rcEigen_Vector2f_i_pDrawInterface_pHectorDebugInfoInterface(float carg1, int carg2, int carg3, SwigObj * carg4, int carg5, SwigObj * carg6, SwigObj * carg7);
HectorSlamProcessor * new_HectorSlamProcessor_f_i_i_rcEigen_Vector2f_i_pDrawInterface(float carg1, int carg2, int carg3, SwigObj * carg4, int carg5, SwigObj * carg6);
HectorSlamProcessor * new_HectorSlamProcessor_f_i_i_rcEigen_Vector2f_i(float carg1, int carg2, int carg3, SwigObj * carg4, int carg5);
void delete_HectorSlamProcessor(HectorSlamProcessor * carg1);
void HectorSlamProcessor_update_phectorslam_HectorSlamProcessor_rchectorslam_DataPointContainer_Sl_Eigen_Vector2f_Sg__rcEigen_Vector3f_b(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3, bool carg4);
void HectorSlamProcessor_update_phectorslam_HectorSlamProcessor_rchectorslam_DataPointContainer_Sl_Eigen_Vector2f_Sg__rcEigen_Vector3f(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3);
void HectorSlamProcessor_reset(SwigObj * carg1);
SwigObj * HectorSlamProcessor_getLastScanMatchPose(SwigObj * carg1);
SwigObj * HectorSlamProcessor_getLastScanMatchCovariance(SwigObj * carg1);
float HectorSlamProcessor_getScaleToMap(SwigObj * carg1);
int HectorSlamProcessor_getMapLevels(SwigObj * carg1);
SwigObj * HectorSlamProcessor_getGridMap_pchectorslam_HectorSlamProcessor_i(SwigObj * carg1, int carg2);
SwigObj * HectorSlamProcessor_getGridMap_pchectorslam_HectorSlamProcessor(SwigObj * carg1);
void HectorSlamProcessor_addMapMutex(SwigObj * carg1, int carg2, SwigObj * carg3);
/*aaaaaa*/SwigObj * HectorSlamProcessor_getMapMutex(SwigObj * carg1, int carg2);
void HectorSlamProcessor_setUpdateFactorFree(SwigObj * carg1, float carg2);
void HectorSlamProcessor_setUpdateFactorOccupied(SwigObj * carg1, float carg2);
void HectorSlamProcessor_setMapUpdateMinDistDiff(SwigObj * carg1, float carg2);
void HectorSlamProcessor_setMapUpdateMinAngleDiff(SwigObj * carg1, float carg2);

typedef SwigObj DataPointContainer_Eigen_Vector2f;

DataPointContainer_Eigen_Vector2f * new_DataPointContainer_Eigen_Vector2f_i(int carg1);
DataPointContainer_Eigen_Vector2f * new_DataPointContainer_Eigen_Vector2f();
void DataPointContainer_Eigen_Vector2f_setFrom(SwigObj * carg1, SwigObj * carg2, float carg3);
void DataPointContainer_Eigen_Vector2f_add(SwigObj * carg1, SwigObj * carg2);
void DataPointContainer_Eigen_Vector2f_clear(SwigObj * carg1);
int DataPointContainer_Eigen_Vector2f_getSize(SwigObj * carg1);
SwigObj * DataPointContainer_Eigen_Vector2f_getVecEntry(SwigObj * carg1, int carg2);
SwigObj * DataPointContainer_Eigen_Vector2f_getOrigo(SwigObj * carg1);
void DataPointContainer_Eigen_Vector2f_setOrigo(SwigObj * carg1, SwigObj * carg2);
void delete_DataPointContainer_Eigen_Vector2f(DataPointContainer_Eigen_Vector2f * carg1);

typedef SwigObj GridMap;

GridMap * new_GridMap(float carg1, SwigObj * carg2, SwigObj * carg3);
void delete_GridMap(GridMap * carg1);
void GridMap_updateSetOccupied(SwigObj * carg1, int carg2);
void GridMap_updateSetFree(SwigObj * carg1, int carg2);
void GridMap_updateUnsetFree(SwigObj * carg1, int carg2);
float GridMap_getGridProbabilityMap(SwigObj * carg1, int carg2);
bool GridMap_isOccupied_pchectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__i_i(SwigObj * carg1, int carg2, int carg3);
bool GridMap_isFree_pchectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__i_i(SwigObj * carg1, int carg2, int carg3);
bool GridMap_isOccupied_pchectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__i(SwigObj * carg1, int carg2);
bool GridMap_isFree_pchectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__i(SwigObj * carg1, int carg2);
float GridMap_getObstacleThreshold(SwigObj * carg1);
void GridMap_setUpdateFreeFactor(SwigObj * carg1, float carg2);
void GridMap_setUpdateOccupiedFactor(SwigObj * carg1, float carg2);
void GridMap_updateByScan(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3);
void GridMap_updateLineBresenhami_phectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__rcEigen_Vector2i_rcEigen_Vector2i_unsigned_SS_int(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3, unsigned int carg4);
void GridMap_updateLineBresenhami_phectorslam_OccGridMapBase_Sl_LogOddsCell_Sc_GridMapLogOddsFunctions_Sg__rcEigen_Vector2i_rcEigen_Vector2i(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3);
void GridMap_bresenhamCellFree(SwigObj * carg1, unsigned int carg2);
void GridMap_bresenhamCellOcc(SwigObj * carg1, unsigned int carg2);
void GridMap_bresenham2D(SwigObj * carg1, unsigned int carg2, unsigned int carg3, int carg4, int carg5, int carg6, unsigned int carg7);

typedef SwigObj GridMapBase_LogOddsCell;

bool GridMapBase_LogOddsCell_hasGridValue(SwigObj * carg1, int carg2, int carg3);
SwigObj * GridMapBase_LogOddsCell_getMapDimensions(SwigObj * carg1);
int GridMapBase_LogOddsCell_getSizeX(SwigObj * carg1);
int GridMapBase_LogOddsCell_getSizeY(SwigObj * carg1);
bool GridMapBase_LogOddsCell_pointOutOfMapBounds(SwigObj * carg1, SwigObj * carg2);
void GridMapBase_LogOddsCell_reset(GridMapBase_LogOddsCell * carg1);
void GridMapBase_LogOddsCell_clear(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getMapDimProperties(SwigObj * carg1);
GridMapBase_LogOddsCell * new_GridMapBase_LogOddsCell_f_rcEigen_Vector2i_rcEigen_Vector2f(float carg1, SwigObj * carg2, SwigObj * carg3);
void delete_GridMapBase_LogOddsCell(GridMapBase_LogOddsCell * carg1);
void GridMapBase_LogOddsCell_allocateArray(SwigObj * carg1, SwigObj * carg2);
void GridMapBase_LogOddsCell_deleteArray(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getCell_phectorslam_GridMapBase_Sl_LogOddsCell_Sg__i_i(SwigObj * carg1, int carg2, int carg3);
SwigObj * GridMapBase_LogOddsCell_getCell_pchectorslam_GridMapBase_Sl_LogOddsCell_Sg__i_i(SwigObj * carg1, int carg2, int carg3);
SwigObj * GridMapBase_LogOddsCell_getCell_phectorslam_GridMapBase_Sl_LogOddsCell_Sg__i(SwigObj * carg1, int carg2);
SwigObj * GridMapBase_LogOddsCell_getCell_pchectorslam_GridMapBase_Sl_LogOddsCell_Sg__i(SwigObj * carg1, int carg2);
void GridMapBase_LogOddsCell_setMapGridSize(SwigObj * carg1, SwigObj * carg2);
GridMapBase_LogOddsCell * copy_GridMapBase_LogOddsCell(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getWorldCoords(SwigObj * carg1, SwigObj * carg2);
SwigObj * GridMapBase_LogOddsCell_getMapCoords(SwigObj * carg1, SwigObj * carg2);
SwigObj * GridMapBase_LogOddsCell_getWorldCoordsPose(SwigObj * carg1, SwigObj * carg2);
SwigObj * GridMapBase_LogOddsCell_getMapCoordsPose(SwigObj * carg1, SwigObj * carg2);
void GridMapBase_LogOddsCell_setDimensionProperties_phectorslam_GridMapBase_Sl_LogOddsCell_Sg__rcEigen_Vector2f_rcEigen_Vector2i_f(SwigObj * carg1, SwigObj * carg2, SwigObj * carg3, float carg4);
void GridMapBase_LogOddsCell_setDimensionProperties_phectorslam_GridMapBase_Sl_LogOddsCell_Sg__rcMapDimensionProperties(SwigObj * carg1, SwigObj * carg2);
void GridMapBase_LogOddsCell_setMapTransformation(SwigObj * carg1, SwigObj * carg2, float carg3);
float GridMapBase_LogOddsCell_getScaleToMap(SwigObj * carg1);
float GridMapBase_LogOddsCell_getCellLength(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getWorldTmap(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getWorldTmap3D(SwigObj * carg1);
SwigObj * GridMapBase_LogOddsCell_getMapTworld(SwigObj * carg1);
void GridMapBase_LogOddsCell_setUpdated(SwigObj * carg1);
int GridMapBase_LogOddsCell_getUpdateIndex(SwigObj * carg1);

#endif /* _HectorSlam_proxy_H_ */
